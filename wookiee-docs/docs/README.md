# wookiee
* [wookiee-grpc](#wookiee-grpc)

# wookiee-grpc
## Install
wookiee-grpc is available for Scala 2.12 and 2.13. There are no plans to support scala 2.11 or lower.
```scala
libraryDependencies += "com.oracle.infy" %% "wookiee-grpc" % "@VERSION@"
```


## Setup ScalaPB
We use [ScalaPB](https://github.com/scalapb/ScalaPB) to generate source code from a `.proto` file. You can use
other plugins/code generators if you wish. wookiee-grpc will work as long as you have `io.grpc.ServerServiceDefinition`
for the server and something that accept `io.grpc.ManagedChannel` for the client.

Declare your gRPC service using proto3 syntax and save it in `@PROTO_FILE@`
```proto
@PROTO_DEF@
```

Add ScalaPB plugin to `plugin.sbt` file
```sbt
@PLUGIN_DEF@
```

Configure the project in `build.sbt` so that ScalaPB can generate code
```sbt
@PROJECT_DEF@
```

In the sbt shell, type `protocGenerate` to generate scala code based on the `.proto` file. ScalaPB will generate
code and put it under `target/scala-2.13/src_managed/main`.

## Using wookiee-grpc
After the code has been generated by ScalaPB, you can use wookiee-grpc for service discoverability and load balancing.

wookiee-grpc is written using functional concepts. One key concept is side-effect management/referential transparency.
We use cats-effect (https://typelevel.org/cats-effect/) internally.
If you want to use cats-effect, you can use the methods that return `IO[_]`. Otherwise, use the methods prefixed with `unsafe`.
When using `unsafe` methods, you are expected to handle any exceptions

### Imports
Add the following imports:
```sbt
@IMPORTS@
```

### Creating a Server
```sbt
@CREATE_SERVER@
```


### Creating a Client Channel
```sbt
@CHANNEL_SETTINGS@
```

### Executing a gRPC Call
```sbt
@GRPC_CALL@
```


###Setting up load balancing methods in channel settings

There are three load balancing policies that ship with wookiee-grpc.
The load balancing policies are set up within the gRPC Channel Settings.

* **Round Robin**

  A simple round robin policy that alternates between hosts as calls are executed. It's fairly simplistic.


* **Round Robin Weighted**

  This load balancer takes server load into consideration and distributes calls to the server with the lowest
  current usage. If all loads are equivalent, it defaults to simple Round Robin behavior.


* **Round Robin Hashed**

  Provides "stickiness" for the gRPC host. If you want a particular host to serve the request for all the calls with a
  particular key, you can use this policy. For example, if you want a single server to service all requests that use
  the key "foo", you can set the `WookieeGrpcChannel.hashKeyCallOption` on every call. This will ensure that all gRPC calls using the same
  hash will be executed on the same server.

```sbt
@GRPC_CALL@
```

## Putting it all together

Here is an example of a complete gRPC solution

```scala mdoc
@EXAMPLE@
Example.main(Array.empty[String])
```
